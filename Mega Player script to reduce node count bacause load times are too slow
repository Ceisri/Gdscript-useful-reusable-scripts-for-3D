extends KinematicBody
#player rotation, animation and otherwise mostly visual stuff
onready var player_mesh = get_node("Mesh")
onready var an = $Mesh/AnimationPlayer
var blend = 0.25
var is_in_combat = false
var duel_wield_mode = false
var bow_mode = false
var two_handed_sword_mode = false
var one_handed_sword_mode = false
var sword_and_shield_mode = false
var crossbow_mode = false
var magic_staff_mode = false
var barehanded_mode = true
var can_move = true 
#collision booleans 
var has_ride = false 
# movement variables
var velocity := Vector3()
export var gravity = 9.8
export var sprint_speed = 20
var teleport_distance = 35
var attack_move_speed = 4.5
export (float) var mouse_sense = 0.1
# Dodge
export var double_press_time: float = 0.4
var dash_countback: int = 0
var dash_timerback: float = 0.0
# Dodge Left
var dash_countleft: int = 0
var dash_timerleft: float = 0.0
# Dodge right
var dash_countright: int = 0
var dash_timerright: float = 0.0
# Dodge forward
var dash_countforward: int = 0
var dash_timerforward: float = 0.0
# Dodge multidirection (not in strafe mode)
var dash_count1 : int = 0
var dash_timer1 : float = 0.0
var dash_count2 : int = 0
var dash_timer2 : float = 0.0
# Condition States
var enabled_climbing = true
var is_riding = bool()
var is_falling = bool()
var is_swimming =bool()
var is_rolling = bool()
var is_walking = false
var was_walking = false
var is_running = bool()
var is_sprinting = bool()
var is_aiming = bool()
var is_cursor = false
var is_crouching = bool()
var attacking = bool()
var is_sliding = false
var is_guarding = false
var is_climbing = false
var mousemode = bool()
var staggered = false
var blocking = false
var backstep = bool()
var frontstep = bool()
var leftstep = bool()
var rightstep =bool()
var stunned = false
var injured = false
# Physics values
var direction = Vector3()
var horizontal_velocity = Vector3()
var aim_turn = float()
var movement = Vector3()
var vertical_velocity = Vector3()
var movement_speed = int()
var angular_acceleration = int()
var acceleration = int()
#preloads and loads  for UI
#onready var tool_tip = load("res://player/UI/HoverText/Test.tscn")
#other UI stuff 
#onready var all_ui = $AllUIHere
#onready var warden_skill_ui = $AllUIHere/Skills/WardenSkills
#onready var debugger = $AllUIHere/Debugger
#Save data
const SAVE_DIR = "user://saves/"
var save_path = SAVE_DIR + "save.dat"
#_________________________________________States and Attributes_____________________________________
var level = 0
var entity_name = "Cei"
#crude stats

var health = 100
const base_health = 100
var max_health = 100
const base_max_health = 100
var energy = 100
var max_energy = 100
const base_max_energy = 100
var resolve = 100
var max_resolve = 100
const base_max_resolve = 100

const base_weight = 60
var weight = 60
const base_walk_speed = 6
var walk_speed =6
const base_run_speed = 8
var run_speed = 15
const base_crouch_speed = 2
var crouch_speed = 2
const base_jumping_power = 20
var jumping_power = 20
const base_dash_power = 20
var dash_power = 20
var attribute = 1000
var skill_points = 1000
var defense =  10
var coordination = 1

var creativity = 1
var wisdom = 1
var memory = 1
var intelligence = 1
var willpower = 1

var power = 1
var strength = 1.5
var impact = 1
var resistance = 1
var tenacity = 1

var accuracy = 1
var dexterity = 1

var balance = 1
var focus = 1

var acrobatics = 1
var agility = 1
var athletics = 1
var flexibility = 1
var placeholder_ = 1

var endurance = 1
var stamina = 1
var vitality = 1
var vigor = 1
var recovery = 1

var charisma = 1
var loyalty = 1 
var diplomacy = 1
var leadership = 1
var empathy = 1
#Leveling compounding attributes 
var spent_attribute_points_cre = 0
var spent_attribute_points_wis = 0
var spent_attribute_points_mem = 0
var spent_attribute_points_int = 0
var spent_attribute_points_wil = 0

var spent_attribute_points_pow = 0
var spent_attribute_points_str = 0
var spent_attribute_points_imp = 0
var spent_attribute_points_res = 0
var spent_attribute_points_ten = 0

var spent_attribute_points_acc = 0
var spent_attribute_points_dex = 0

var spent_attribute_points_bal = 0
var spent_attribute_points_foc = 0

var spent_attribute_points_acr = 0
var spent_attribute_points_agi = 0
var spent_attribute_points_ath = 0
var spent_attribute_points_fle = 0
#var placeholder_

var spent_attribute_points_end = 0
var spent_attribute_points_sta = 0
var spent_attribute_points_vit = 0
var spent_attribute_points_vig = 0
var spent_attribute_points_rec = 0

var spent_attribute_points_cha = 0
var spent_attribute_points_loy = 0 
var spent_attribute_points_dip = 0
var spent_attribute_points_lea = 0
var spent_attribute_points_emp = 0
#_______stored______
var st_charisma = charisma
var st_loyalty =  loyalty
var st_diplomacy = diplomacy
var st_leadership = leadership
var st_empathy = empathy

var st_accuracy = accuracy
var st_dexterity = dexterity
var st_coordination = coordination
var st_balance = balance
var st_focus = focus

var st_endurance = endurance
var st_stamina = stamina
var st_vitality = vitality
var st_vigor = vigor
var st_recovery = recovery

var st_acrobatics = acrobatics
var st_agility = agility
var st_athletics = athletics
var st_flexibility = flexibility
var st_placeholder = placeholder_

var st_power = power
var st_strength = strength
var st_impact = impact
var st_resistance = resistance
var st_tenacity = tenacity

var st_creativity = creativity
var st_wisdom = wisdom
var st_memory = memory
var st_intelligence = intelligence
var st_willpower = willpower
#___________________________________Class Specific____________________________________________
#set1
var has_headstrong_rush_skill = false

#invested points 
var headstrong_rush_ps = 0
var pomel_strike_ps = 0
var cross_parry_ps = 0
var measured_slice_ps = 0 
var blood_rush_ps = 0
#headstrong rush skill 
#onready var HeadstrongrushCD = $AllUIHere/Skills/WardenSkills/Set1/HeadstrongRush/HeadstrongrushCD
var headstrong_duration = 5
var headstrong_rush_toggle = false
#set3
var has_pomel_strike_skill = true
var has_entagle_skill = false 
var has_disarm_skill = false
var has_expose_skill = false
var has_cripple_skill = false 
#set4
var has_wallop_skill = false
var has_rising_strike_skill = false
var has_schadenfreude_skill = false
var has_eviscerate_skill = false 
var has_punishing_blow_skill = false 
#set5
var has_shield_bash_counter_skill = false
var has_lunge_skill = false 
var has_provocation_skill = false 
var has_shield_barrage_skill = false #move and attack while covered behind the shield at the same time 
var has_shield_counter_skill= false #after blocking a hit, bash enemy with the shield and trust


func _ready():

	#instanceui()
	set_process_input(true)	
	direction = Vector3.BACK.rotated(Vector3.UP,  camera_h.global_transform.basis.get_euler().y)
	loadPlayerData()
	# Load the tooltip scene
	Input.set_mouse_mode(Input.MOUSE_MODE_CAPTURED)
func _input(event):
	if event is InputEventKey:
		if event.scancode == KEY_P:  # Replace with the desired key code
			resetSavedData()
	if event is InputEventMouseMotion:
		camrot_h += -event.relative.x * h_sensitivity
		camrot_v += event.relative.y * v_sensitivity
		if minimap_rotate:
			minimap_camera.rotate_y(deg2rad(-event.relative.x * mouse_sense))
	#Scrollwheel zoom in and out 		
	if event is InputEventMouseButton and event.button_index == BUTTON_WHEEL_UP:
		# Zoom in when scrolling up
		Zoom(-1)
	elif event is InputEventMouseButton and event.button_index == BUTTON_WHEEL_DOWN:
		# Zoom out when scrolling down
		Zoom(1)


func _physics_process(delta):
	if not stunned:
			jump()
			dodgeBack(delta)
			dodgeFront(delta)
			dodgeLeft(delta)
			dodgeRight(delta)	
			move()
			movementStates()
			climbing()
			teleport()
			minimapFollow()
			MainWeapon()
			SecWeapon()
			if Input.is_action_just_pressed("ui_focus_next"):
				is_in_combat = !is_in_combat
			if Input.is_action_just_pressed("1"):
				barehanded_mode = false
				#duel_wield_mode = true 
				sword_and_shield_mode = true 
	mouseMode()		
	stiffCamera(delta)	
	ridingCollision()
	Gravity(delta)
	interpol(delta)
	gliding()
#	debug()
	animationsAll(delta)
	cameraRotation(delta)
	unstuckDisplayCD()
	unstuckVisibility()
	unstuckDisplayCD()
#__________________________________________Movement_________________________________
var run_toggle = false
var crouch_toggle = false
var sprint_toggle = false
func move():
	var h_rot =  camera_h.global_transform.basis.get_euler().y
	movement_speed = 0
	angular_acceleration = 3.25
	acceleration = 15
	movement.z = horizontal_velocity.z + vertical_velocity.z
	movement.x = horizontal_velocity.x + vertical_velocity.x
	movement.y = vertical_velocity.y
	move_and_slide(movement, Vector3.UP)
	if not is_climbing:
		if Input.is_action_pressed("forward") or Input.is_action_pressed("backward") or Input.is_action_pressed("left") or Input.is_action_pressed("right"):
			direction = Vector3(Input.get_action_strength("left") - Input.get_action_strength("right"),
						0,
						Input.get_action_strength("forward") - Input.get_action_strength("backward"))
			direction = direction.rotated(Vector3.UP, h_rot).normalized()
			is_walking = true
		else: 
			is_walking = false
func movementStates():
	if is_walking:	
			# Movement States
		if Input.is_action_pressed("run") and is_walking and not is_climbing and not blocking and not is_swimming and not is_aiming:
					movement_speed = run_speed
					is_in_combat = false
					is_running = true
					enabled_climbing = false
					is_crouching = false
					is_aiming = false
		elif Input.is_action_pressed("C") and is_walking and !is_climbing and !is_swimming:
				movement_speed = crouch_speed
				is_running = false
				enabled_climbing = false
				is_crouching = true
				is_aiming = false
				is_in_combat = false
		elif Input.is_action_pressed("sprint") and is_walking and not is_climbing and not blocking and not is_swimming and not is_aiming:
					movement_speed = sprint_speed
					is_sprinting = true
					enabled_climbing = false
					is_crouching = false
					is_aiming = false
					is_in_combat = false
		else:  # Walk State and speed
				movement_speed = walk_speed
				is_sprinting = false
				is_crouching = false
				enabled_climbing = true
				is_crouching = false
				is_running = false
	else:  # Walk State and speed
			is_sprinting = false
			is_crouching = false
			enabled_climbing = true
			is_crouching = false
			is_running = false
func dodgeBack(delta):#Doddge when in strafe mode
		if dash_countback > 0:
			dash_timerback += delta
		if dash_timerback >= double_press_time:
			dash_countback = 0
			dash_timerback = 0.0
		if Input.is_action_just_pressed("backward"):
			dash_countback += 1
		if dash_countback == 2 and dash_timerback < double_press_time:
			horizontal_velocity = direction * dash_power
			backstep = true
			enabled_climbing = false
		else:
			enabled_climbing = true
			backstep = false
func dodgeFront(delta):#Dodge when in strafe mode
		if dash_countforward > 0:
			dash_timerforward += delta
		if dash_timerforward >= double_press_time:
			dash_countforward = 0
			dash_timerforward = 0.0
		if Input.is_action_just_pressed("forward"):
			dash_countforward += 1
		if dash_countforward == 2 and dash_timerforward < double_press_time:
			horizontal_velocity = direction * dash_power *1.5
			frontstep = true
			enabled_climbing = false
		else:
			enabled_climbing = true
			frontstep = false
func dodgeLeft(delta):#Dodge when in strafe mode
		if dash_countleft > 0:
			dash_timerleft += delta
		if dash_timerleft >= double_press_time:
			dash_countleft = 0
			dash_timerleft = 0.0
		if Input.is_action_just_pressed("left"):
			dash_countleft += 1
		if dash_countleft == 2 and dash_timerleft < double_press_time:
			horizontal_velocity = direction * dash_power
			enabled_climbing = false
			leftstep = true
		else:
			enabled_climbing = true
			leftstep = false
func dodgeRight(delta):#Dodge when in strafe mode
		if dash_countright > 0:
			dash_timerright += delta
		if dash_timerright >= double_press_time:
			dash_countright = 0
			dash_timerright = 0.0
		if Input.is_action_just_pressed("right"):
			dash_countright += 1
		if dash_countright == 2 and dash_timerright < double_press_time :
			horizontal_velocity = direction * dash_power
			enabled_climbing = false
			rightstep = true
		else:
			enabled_climbing = true
			rightstep = false
func teleport():
	if Input.is_action_just_pressed("X"):
		var teleport_vector = direction.normalized() * teleport_distance
		var teleport_position = translation + teleport_vector
		var collision = move_and_collide(teleport_vector)
		if collision:
			teleport_position = collision.position
			translation = teleport_position
#climbing section
var wall_incline
var is_wall_in_range = false
onready var head_ray =$Mesh/HeadRay
func climbing():
	if not is_swimming:
		if is_on_wall():
			if  Input.is_action_pressed("forward"):
					checkWallInclination()
					vertical_velocity = Vector3.UP * (strength + (agility * 0.15))
					#horizontal_velocity = direction * 1
					is_climbing = true
					is_swimming = false
					if not head_ray.is_colliding() and not is_wall_in_range:#vaulting
						an.play("TPose",blend, strength)#vaulting animation placeholder
					elif not is_wall_in_range:#normal climb
						an.play("climb",blend, strength)
					else:
						an.play("crawl incline", blend, strength)
						horizontal_velocity = direction * walk_speed
			else:
				is_climbing = false
		else:
			is_climbing = false
func checkWallInclination():
	if get_slide_count() > 0:
		var collision_info = get_slide_collision(0)
		var normal = collision_info.normal
		if normal.length_squared() > 0:
			wall_incline = acos(normal.y)  # Calculate the inclination angle in radians
			wall_incline = rad2deg(wall_incline)  # Convert inclination angle to degrees
			if normal.x < 0:
				wall_incline = -wall_incline
			# Check if the wall inclination is within the specified range 
			is_wall_in_range = (wall_incline >= -60 and wall_incline <= 60)
		else:
			wall_incline = 0  # Set to 0 if the normal is not valid
			is_wall_in_range = false
	else:
		wall_incline = 0  # Set to 0 if there is no collision
		is_wall_in_range = false
func jump():
	if Input.is_action_pressed("jump") and is_on_floor():
		vertical_velocity = Vector3.UP *  jumping_power
	if Input.is_action_pressed("jump") and is_swimming:
		vertical_velocity = Vector3.UP * 5
	elif Input.is_action_pressed("C") and is_swimming:
		vertical_velocity = Vector3.DOWN * 5
func gliding():
	if is_falling:
		if Input.is_action_pressed("Z"):
			vertical_velocity = direction * 1 
			horizontal_velocity = direction * 20 * agility 
			vertical_velocity = Vector3.ZERO  # No vertical movement while gliding
			movement_speed =  walk_speed
			an.play("TPose")
			is_in_combat = false 
func interpol(delta):
	horizontal_velocity = horizontal_velocity.linear_interpolate(direction.normalized() * movement_speed, acceleration * delta)
func Gravity(delta):# Gravity and stop sliding on floors
	if not is_climbing:
		if not is_on_floor() and not is_swimming:
			vertical_velocity += Vector3.DOWN * 60 * delta
			is_falling = true
		else:
			vertical_velocity = -get_floor_normal() * gravity / 2.5 
			is_falling = false
#___________________________________________Camera_______________________________________________
var camrot_h = 0
var camrot_v = 0
onready var parent = $".."
export var cam_v_max = 200 # -75 recommended
export var cam_v_min = -125 # -55 recommended
onready var camera_v =$Camroot/h/v
onready var camera_h =$Camroot/h
onready var camera = $Camroot/h/v/Camera
onready var minimap = $Minimap
onready var minimap_camera = $Minimap/Viewport/Camera
var minimap_rotate = false
var h_sensitivity = 0.1
var v_sensitivity = 0.1
var rot_speed_multiplier = .15 #reduce this to make the rotation radius larger
var h_acceleration = 10
var v_acceleration = 10
var mouse_captured = true
var touch_start_position = Vector2.ZERO
var zoom_speed = 0.1
# Add this function to handle zooming logic
func Zoom(direction):
	# Adjust the camera's position based on the zoom direction
	camera.translation.y += direction * zoom_speed
	camera.translation.z -= direction * zoom_speed
func _on_Sensitivity_pressed():
	$Minimap/sensitivity_label.text = "cam sens:  " + str(h_sensitivity)
	h_sensitivity += 0.025
func _on_SensitivityMin_pressed():
	h_sensitivity -= 0.025
	$Minimap/sensitivity_label.text = "cam sens:  " + str(h_sensitivity)
func cameraRotation(delta):
	if not is_cursor:
		camrot_v = clamp(camrot_v, cam_v_min, cam_v_max)
		#MOUSE CAMERA
		camera_h.rotation_degrees.y = lerp(camera_h.rotation_degrees.y, camrot_h, delta * h_acceleration)
		camera_v.rotation_degrees.x = lerp(camera_v.rotation_degrees.x, camrot_v, delta * v_acceleration)
func mouseMode():
	if Input.is_action_pressed("rclick"):
		is_aiming = true
	else:
		is_aiming = false	
	if Input.is_action_just_pressed("ui_cancel"):	# Toggle mouse mode
		is_in_combat = false
		if Input.get_mouse_mode() == Input.MOUSE_MODE_CAPTURED:
			Input.set_mouse_mode(Input.MOUSE_MODE_VISIBLE)
			is_cursor = true
		else:
			Input.set_mouse_mode(Input.MOUSE_MODE_CAPTURED)
			is_cursor = false
func stiffCamera(delta):
		if is_aiming:
			player_mesh.rotation.y = lerp_angle(player_mesh.rotation.y, camera_h.rotation.y, delta * angular_acceleration)
		else:
			player_mesh.rotation.y = lerp_angle(player_mesh.rotation.y, atan2(direction.x, direction.z) - rotation.y, delta * angular_acceleration)	
func minimapFollow():# Update the position of the minimap camera
	minimap_camera.translation = Vector3(translation.x, 30,translation.z)
#_______________________________________Collisions__________________________________
func ridingCollision():
	if has_ride:
		# If has_horse is true, change collision layers
		set_collision_layer(6)  # Set to the desired collision layer
		set_collision_mask(6)   # Set to the desired collision mask
	elif not has_ride:
		# If has_horse is false, reset collision layers
		set_collision_layer(1)  # Set to the original collision layer
		set_collision_mask(1)   # Set to the original collision mask
#__________________________________Animation Section_____________________________________
func animationsAll(delta):
	if is_in_combat:
		if barehanded_mode:
			animationsBarehanded()	
		elif one_handed_sword_mode:
			animations1HSword()	
		elif two_handed_sword_mode:
			animations2HSword()
		elif duel_wield_mode:
			animationsDualWield()
		elif bow_mode:
			animationsBow()	
		elif sword_and_shield_mode:
			animationsSwordAndShield(delta)	
	else:
		if not is_swimming:
			if is_aiming:
				animationStrafe()
			else:
				animationOutOfCombat()	
	if is_swimming:
		if is_walking:
			an.play("swim",blend)
		else:
			an.play("swim idle",blend)
	if not is_on_floor() and not is_climbing and not is_swimming:
		an.play("fall loop",blend)
#____________________________________Sword and Shield Animations_______________________________________
func animationsSwordAndShield(delta):
	if Input.is_action_pressed("rclick"): #block
		if  dash_countforward ==2:
			an.play("slide",blend)
		elif  dash_countleft ==2:
			an.play_backwards("dodge right",blend)
		elif  dash_countright ==2:
			an.play("dodge right",blend)
		elif  dash_countback ==2:
			an.play_backwards("backstep",blend)
		elif Input.is_action_pressed("attack") and has_pomel_strike_skill:
			an.play("pomel strike",blend)#placeholder counter attack
			horizontal_velocity = Vector3.ZERO
		elif Input.is_action_pressed("forward") and Input.is_action_pressed("left"):
			an.play("block shield front left",blend)
		elif Input.is_action_pressed("backward") and Input.is_action_pressed("left"):
			an.play_backwards("block shield front right",blend)
		elif Input.is_action_pressed("backward") and Input.is_action_pressed("right"):
			an.play_backwards("block shield front left",blend)
		elif Input.is_action_pressed("forward") and Input.is_action_pressed("right"):
			an.play("block shield front right", blend)
		elif Input.is_action_pressed("backward"):
			an.play_backwards("block shield front ",blend)
		elif Input.is_action_pressed("left"):
			an.play("shield block left",blend)
		elif Input.is_action_pressed("right"):
			an.play("shield block right ",blend)
		elif Input.is_action_pressed("forward"):
			an.play("block shield front ",blend)
		else:
			an.play("block shield",blend/2)	
	else:
		if dash_countback ==2 or dash_countleft ==2 or dash_countright ==2 or dash_countforward ==2:
			an.play("slide",blend)

		elif Input.is_action_pressed("E"):
			an.play("fury strike cycle", blend +0.1)
			moveAttack2(delta)
		elif Input.is_action_pressed("attack"):
			an.play("combo attack sword and shield cycle")
			moveAttack(delta)
		elif is_sliding and attacking:
			an.play("swirl melee attack",blend)
		elif is_walking:
			an.play("walk combat",blend)		
		else:
			an.play("idle combat",blend)
#_________________________________________One handed Sword animations_____________________________________________
func animations1HSword():
	if Input.is_action_pressed("attack"):
		an.play("combo attack 1h")
	elif is_walking:
		if not injured:
			an.play("walk")
		else:
			an.play("walk injured")
	elif is_crouching:
		if is_running:
			an.play("sneak run")
		elif is_walking:
			an.play("sneak walk")
		else:
			an.play("sneak")
	else:
		an.play("idle combat")
#_____________________________________________Two handed Sword_____________________________________
func animations2HSword():
	if Input.is_action_pressed("attack"):
		an.play("combo attack 2h")
	elif is_walking:
		if not injured:
			an.play("walk")
		else:
			an.play("walk injured")
	elif is_crouching:
		if is_running:
			an.play("sneak run")
		elif is_walking:
			an.play("sneak walk")
		else:
			an.play("sneak")
	else:
		an.play("idle combat 2h", blend)
#_____________________________________________Dual Wielding______________________________________________
func animationsDualWield():
	if Input.is_action_pressed("attack"):
		an.play("combo attack 2w", blend)
	elif is_walking:
		if not injured:
			an.play("walk")
		else:
			an.play("walk injured")
	elif is_crouching:
		if is_running:
			an.play("sneak run")
		elif is_walking:
			an.play("sneak walk")
		else:
			an.play("sneak")
	else:
		an.play("idle dual wield", blend)
#__________________________________________Bow______________________________________
func animationsBow():
	if Input.is_action_pressed("attack") and is_walking and not is_aiming:
		an.play("shoot forward", blend)
	elif Input.is_action_pressed("attack") and is_aiming and Input.is_action_pressed("left"):
		an.play("shoot left", blend)
	elif Input.is_action_pressed("attack") and is_aiming and Input.is_action_pressed("right"):
		an.play("shoot right", blend)
	elif Input.is_action_pressed("attack") and is_aiming and Input.is_action_pressed("left"):
		an.play("shoot back", blend)
	elif Input.is_action_pressed("attack") and is_walking :
		an.play("shoot forward", blend)
	elif Input.is_action_pressed("attack"):
		an.play("shoot arrow", blend)
	elif is_walking:
		if not injured:
			an.play("walk")
		else:
			an.play("walk injured")
	elif is_crouching:
		if is_running:
			an.play("sneak run")
		elif is_walking:
			an.play("sneak walk")
		else:
			an.play("sneak")
	else:
		an.play("idle combat", blend)
#___________________________________________Empty Handed_____________________________________________
func animationsBarehanded():
	if Input.is_action_pressed("attack"):
		an.play("kick")	
	elif is_walking:
		if not injured:
			an.play("walk")
		else:
			an.play("walk injured")
	elif is_crouching:
		if is_running:
			an.play("sneak run")
		elif is_walking:
			an.play("sneak walk")
		else:
			an.play("sneak")
	elif Input.is_action_just_pressed("jump"):
		an.play_backwards("terrified")
	else:
		an.play("idle combat")
#____________________________________________Out of Combat_________________________________
func animationOutOfCombat(): #normal
	#dodge section is prioritized
	if dash_countback ==2 or dash_countleft ==2 or dash_countright ==2 or dash_countforward ==2 or is_sliding:
		an.play("slide",blend)
#out of combat normal movement
	elif !is_in_combat and !is_swimming and is_on_floor() and !is_aiming:
		if is_sprinting:
			an.play("run")
		elif is_running:
			an.play("run")
		elif is_walking and Input.is_action_pressed("C"):
			an.play("sneak walk")
		elif is_running and Input.is_action_pressed("C"):
			an.play("sneak run")
		elif is_walking:
			an.play("walk")
		elif Input.is_action_pressed("C"):
			an.play("sneak",blend)
		elif Input.is_action_just_pressed("Q"):
			an.play_backwards("terrified")			
		else:
			an.play("idle", 0.25)
func animationStrafe(): #strafe
	#dodge section is prioritized
		if dash_countback ==2:
			an.play("backstep",blend)
		elif dash_countleft ==2:
			an.play("TPose",blend)
		elif dash_countright ==2:
			an.play("TPose",blend)
		elif dash_countforward ==2:
			an.play_backwards("backstep",blend)
	#strafing walk 
		elif Input.is_action_pressed("forward") and Input.is_action_pressed("left"):
			an.play("left front",blend)
		elif Input.is_action_pressed("backward") and Input.is_action_pressed("left"):
			an.play_backwards("right front",blend)
		elif Input.is_action_pressed("backward") and Input.is_action_pressed("right"):
			an.play_backwards("left front",blend)
		elif Input.is_action_pressed("forward") and Input.is_action_pressed("right"):
			an.play("right front", blend)
		elif Input.is_action_pressed("backward"):
			an.play_backwards("walk",blend)
		elif Input.is_action_pressed("left"):
			an.play("left",blend)
		elif Input.is_action_pressed("right"):
			an.play("right",blend)
		elif Input.is_action_pressed("forward"):
			an.play("walk")
		elif Input.is_action_just_pressed("jump"):
			an.play_backwards("landing")
		else:
			an.play("idle",blend)
#Combat Stufff
func moveAttack(delta):
	if can_move:
		horizontal_velocity = direction * 40 * delta
	else:
		horizontal_velocity = direction * 10.35 * delta
func moveAttack2(delta):
	if can_move:
		horizontal_velocity = direction * 100 * delta
	else:
		horizontal_velocity = direction * 0.35 * delta
func stop():
	can_move = false
func start():
	can_move = true 
	
#________________________________________Graphic User Interface____________________________________
onready var debugger = $"../RichTextLabel"
onready var coordinates = $Minimap/Coordinates
func debugText():
	debugger.text = "Memory: %.3f MB" % (OS.get_static_memory_usage() / (1024.0 * 1024.0))
func roundPositionCoordinates():
	var rounded_position = Vector3(
		round(global_transform.origin.x * 10) / 10,
		round(global_transform.origin.y * 10) / 10,
		round(global_transform.origin.z * 10) / 10
	)
	# Use %d to format integers without decimals
	coordinates.text = "%d, %d, %d" % [rounded_position.x, rounded_position.y, rounded_position.z]
onready var time_label = $Minimap/Time
func displayClock():
	# Get the current date and time
	var datetime = OS.get_datetime()

	# Display hour and minute in the label
	time_label.text = "Time: %02d:%02d" % [datetime.hour, datetime.minute]	
	# Include the cooldown information
	#debugger.text += "\nHeadstrong Rush Cooldown: %.1f" % HeadstrongrushCD.time_left
#_________________________________________Warden Skills_____________________________________________
#func _on_WardenSkillsButton_pressed():
#	warden_skill_ui.visible = true
#_______________________________________________Save Data__________________________________________
func savePlayerData():
	var data = {
		"position": translation,
		"unstuck_cd" : unstuck_cd,
#camera stuff
		"H_rotation": camera_h.rotation_degrees,
		"V_rotation": camera_v.rotation_degrees,
		"camera_position": camera.translation,
		"camera_rotation": camera.rotation_degrees,  # Save the camera's rotation		
#Attributes		
#leveling 
		"attribute": attribute,
		"spent_attribute_points_int": spent_attribute_points_int,
		"spent_attribute_points_wis": spent_attribute_points_wis,
		"spent_attribute_points_cha": spent_attribute_points_cha,
		"spent_attribute_points_vit": spent_attribute_points_vit,
#Brain attributes
		"creativity": creativity,
		"wisdom" : wisdom,
		"memory": memory,
		"intelligence": intelligence,
		"willpower": willpower,

#Brute attributes
		"power": power,
		"strength": strength,
		"impact": impact,
		"resistance": resistance,
		"tenacity": tenacity,

#Precision attributes
		"accuracy": accuracy,
		"dexterity":dexterity,
		"coordination": coordination,
		"balance": balance,
		"focus": focus,

#Nimble attributes
		"acrobatics": acrobatics,
		"agility": agility,
		"athletics": athletics,
		"flexibility": flexibility,
		"placeholder_": placeholder_,

#Toughness attributes
		"endurance": endurance,
		"stamina": stamina,
		"vitality": vitality,
		"vigor": vigor,
		"recovery": recovery,

#Social attributes 
		"charisma":charisma,
		"loyalty": loyalty,
		"diplomacy": diplomacy,
		"leadership": leadership,
		"empathy": empathy,

#crude stats
		"health": health,
		"energy":energy,
		"resolve": resolve,
		"max_health": max_health,
		"max_energy": max_energy,
		"max_resolve": max_resolve,
#hair   
		#"hair0":has_hair0,
		#"hair1": has_hair1,
		#"hair2": has_hair2,
		#"hair3": has_hair3,
		#"hair_color": hair_color,
#skin 
		"skin0": skin0,
		"skin1": skin1,
		"skin2": skin2,
		"skin3": skin3,
#skills 
		"headstrong_rush_ps": headstrong_rush_ps,
		"pomel_strike_ps": pomel_strike_ps,
#inventory
		"got_weapon": got_weapon,
		"got_sec_weapon": got_sec_weapon,
#		"got_shield": got_shield,
		"has_sword0": has_sword0,
		"has_sword1": has_sword1,
		"has_sword2": has_sword2,
		"has_sword3": has_sword3,
		"has_sec_sword0": has_sec_sword0,
		"has_sec_sword1": has_sec_sword1,
		"has_sec_sword2": has_sec_sword2,
		"has_sec_sword3": has_sec_sword3,
#		"has_shield3": has_shield3,
		
		}
	var dir = Directory.new()
	if !dir.dir_exists(SAVE_DIR):
		dir.make_dir_recursive(SAVE_DIR)
	var file = File.new()
	var error = file.open_encrypted_with_pass(save_path, File.WRITE, "P@paB3ar6969")
	if error == OK:
		file.store_var(data)
		file.close()
func loadPlayerData():
	var file = File.new()
	if file.file_exists(save_path):
		var error = file.open_encrypted_with_pass(save_path, File.READ, "P@paB3ar6969")
		if error == OK:
			var player_data = file.get_var()
			file.close()
			if "position" in player_data:
				translation = player_data["position"]
			if "unstuck_cd" in player_data:
				unstuck_cd = player_data["unstuck_cd"]
#attributes 
			if "attribute" in player_data:
				attribute = player_data["attribute"]
			if "spent_attribute_points_int" in player_data:
				spent_attribute_points_int = player_data["spent_attribute_points_int"]
			if "spent_attribute_points_cha" in player_data:
				spent_attribute_points_cha = player_data["spent_attribute_points_cha"]
			if "spent_attribute_points_wis" in player_data:
				spent_attribute_points_wis = player_data["spent_attribute_points_wis"]
			if "spent_attribute_points_vit" in player_data:
				spent_attribute_points_vit = player_data["spent_attribute_points_vit"]
#Brute attributes
			if "power" in player_data:
				power = player_data["power"]
			if "strength" in player_data:
				strength = player_data["strength"]				
			if "impact" in player_data:
				impact = player_data["impact"]				
			if "resistance" in player_data:
				resistance = player_data["resistance"]
			if "tenacity" in player_data:
				tenacity = player_data["tenacity"]
#Brain attributes
			if "creativity" in player_data:
				creativity = player_data["creativity"]
			if "wisdom" in player_data:
				wisdom = player_data["wisdom"]
			if "memory" in player_data:
				memory = player_data["memory"]				
			if "intelligence" in player_data:
				intelligence = player_data["intelligence"]				
			if "willpower" in player_data:
				willpower = player_data["willpower"]
#Precision attributes
			if 	"accuracy" in player_data:
				 accuracy = player_data["accuracy"]
			if "dexterity" in player_data:
				dexterity = player_data["dexterity"]
			if "cooridnation" in player_data:
				coordination = player_data["cooridnation"]								
			if "balance" in player_data:
				balance = player_data["balance"]
			if "focus" in player_data:
				focus  = player_data["focus"]
#Nimble attributes
			if "acrobatics" in player_data:
				 acrobatics = player_data["accuracy"]
			if "agility" in player_data:
				 agility = player_data["agility"]
			if "flexibility" in player_data:
				flexibility = player_data["flexibility"]
			if "athletics" in player_data:
				athletics = player_data["athletics"]				
#Toughness attributes
			if "endurance" in player_data:
				dexterity = player_data["endurance"] 
			if "stamina" in player_data:
				stamina = player_data["stamina"]
			if "vitality" in player_data:
				vitality = player_data["vitality"]
			if "vigor" in player_data:
				vigor = player_data["vigor"]
			if "recovery" in player_data:
				recovery = player_data["recovery"]
#Social attributes 
			if "charisma" in player_data:
				charisma = player_data["charisma"]
			if "loyalty" in player_data:
				loyalty = player_data["loyalty"]
			if "diplomacy" in player_data:
				diplomacy = player_data["diplomacy"]
			if "leadership" in player_data:
				leadership = player_data["leadership"]
			if "empathy" in player_data:
				empathy = player_data["empathy"]
#crude stats 				
			if "health" in player_data:
				health = player_data["health"]
			if "max_health" in player_data:
				max_health = player_data["max_health"]				
			if "energy" in player_data:
				energy = player_data["energy"]
			if "max_energy" in player_data:
				max_energy = player_data["max_energy"]
			if "resolve" in player_data:
				resolve = player_data["resolve"]
			if "max_resolve" in player_data:
				max_resolve = player_data["max_resolve"]
#skills 
			if "headstrong_rush_ps" in player_data:
				headstrong_rush_ps = player_data["headstrong_rush_ps"]
			if "pomel_strike_ps" in player_data:
				pomel_strike_ps = player_data["pomel_strike_ps"]
#skins      
			if "skin0" in player_data:
				skin0 = player_data["skin0"]
			if "skin1" in player_data:
				skin1 = player_data["skin1"]
			if "skin2" in player_data:
				skin2 = player_data["skin2"]
			if "skin3" in player_data:
				skin3 = player_data["skin3"]
#inventory 
			if "got_weapon" in player_data:
				got_weapon = player_data["got_weapon"]
			if "got_sec_weapon" in player_data:
				got_sec_weapon = player_data["got_sec_weapon"]
#			if "got_shield" in player_data:
#				got_shield = player_data["got_shield"]
			if "has_sword0" in player_data:
				has_sword0 = player_data["has_sword0"]
			if "has_sword1" in player_data:
				has_sword1 = player_data["has_sword1"]
			if "has_sword2" in player_data:
				has_sword2 = player_data["has_sword2"]
			if "has_sword3" in player_data:
				has_sword3 = player_data["has_sword3"]
			if "has_sec_sword0" in player_data:
				has_sec_sword0 = player_data["has_sec_sword0"]
			if "has_sec_sword1" in player_data:
				has_sec_sword1 = player_data["has_sec_sword1"]
			if "has_sec_sword2" in player_data:
				has_sec_sword2 = player_data["has_sec_sword2"]
			if "has_sec_sword3" in player_data:
				has_sec_sword3 = player_data["has_sec_sword3"]
#			if "has_shield3" in player_data:
#				has_shield3 = player_data["has_shield3"]	
func resetSavedData():
	var dir = Directory.new()
	if dir.file_exists(save_path):
		dir.remove(save_path)
		print("Saved data reset")
func _on_SaveDataTimer_timeout():
	savePlayerData()
#___________________________________________HeadStrong Rush UI______________________________
func _on_HeadstrongRush_pressed():
	if headstrong_rush_ps < 5:
		headstrong_rush_ps += 1
		skill_points -= 1		
		if headstrong_rush_ps > 0:
			has_headstrong_rush_skill = true 
	$AllUIHere/Skills/WardenSkills/Set1/HeadstrongRush/SkillLevel.text = str(headstrong_rush_ps)
func _on_HeadstrongRush_mouse_exited():
	for child in get_children():
		if child.is_in_group("Tooltip"):
			child.queue_free()	
#func _on_HeadstrongRush_mouse_entered():
#	var tool_tip_instance = tool_tip.instance()
	#var skill_name = "Headstrong Rush:"
	#var for_text = "Charge a short distance at high speed dealing damage to enemies that you collide with"
#	add_child(tool_tip_instance)
#	tool_tip_instance._make_custom_tooltip(for_text)
	#tool_tip_instance.skillName(skill_name)
#func _on_PomelStrike_mouse_entered():
#	var tool_tip_instance = tool_tip.instance()
#	var skill_name = "Pomel Strike"
#	var for_text = "counter strike with a pome"
#	add_child(tool_tip_instance)
#	tool_tip_instance._make_custom_tooltip(for_text)
#	tool_tip_instance.skillName(skill_name)
#func _on_PomelStrike_mouse_exited():
#	for child in get_children():
#		if child.is_in_group("Tooltip"):
#			child.queue_free()	
#________________________________________Headstrong Rush skill______________________________
func _on_Duration_timeout():
	headstrong_rush_toggle = false
	is_running = false
#func _on_HeadstrongrushCD_timeout():
#	 HeadstrongrushCD.stop()
func _on_PomelStrike_pressed():
	if pomel_strike_ps < 5:
		pomel_strike_ps += 1
		skill_points -= 1		
		if pomel_strike_ps > 0:
			has_pomel_strike_skill = true 
	$AllUIHere/Skills/WardenSkills/Set1/PomelStrike/SkillLevel.text = str(pomel_strike_ps)	
func updateSkills():
	if pomel_strike_ps > 0:
		has_pomel_strike_skill = true 
	if headstrong_rush_ps > 0:
		has_headstrong_rush_skill = true 	
	$AllUIHere/Skills/WardenSkills/Set1/PomelStrike/SkillLevel.text = str(pomel_strike_ps)
	$AllUIHere/Skills/WardenSkills/Set1/HeadstrongRush/SkillLevel.text = str(headstrong_rush_ps)
func _on_MinimapRotation_pressed():
	minimap_rotate = !minimap_rotate
#__________________________________________optimization and performance__________________________________________________________________	
func _on_FPS_pressed():
	var current_fps = Engine.get_target_fps()
	if current_fps == 15:
		Engine.set_target_fps(20)
	elif current_fps == 20:
		Engine.set_target_fps(25)
	elif current_fps == 25:
		Engine.set_target_fps(30)
	elif current_fps == 30:
		Engine.set_target_fps(35)
	elif current_fps == 35:
		Engine.set_target_fps(40)
	elif current_fps == 40:
		Engine.set_target_fps(80)
	elif current_fps == 80:
		Engine.set_target_fps(15)
func updateFPS():
	$Minimap/FPSLabel.text  = "%d" % Engine.get_frames_per_second()
#_____________________________________________Water Detection________________________________________________________________
func _on_WaterDetector_area_entered(area):
	if area.is_in_group("Water"):
		is_swimming = true
func _on_WaterDetector_area_exited(area):
	if area.is_in_group("Water"):
		is_swimming = false
#_______________________________________________________skin editor__________________________________________________
onready var torso = $Mesh/Armature020/Skeleton/torso0
onready var legs = $Mesh/Armature020/Skeleton/legs0
onready var face = $Mesh/Armature020/Skeleton/face
onready var feet = $Mesh/Armature020/Skeleton/feet0
onready var hands = $Mesh/Armature020/Skeleton/hands0
#onready var body_material = preload("res://player/body_002.material")
#onready var test_replace_material = preload("res://World/Material_001.material")
var skin0 = false
var skin1 = false
var skin2 = false
var skin3 = false 
#__________________________________________Unstuck button, teleports the player to world origin when stuck_______________________________
var unstuck_cd = 0
onready var unstuck_label =  $Minimap/UnstuckCDProgressBar/CdLabel
onready var unstuck_button = $Minimap/Unstcuk
onready var unstuck_cd_progress_bar = $Minimap/UnstuckCDProgressBar
func unstuckDisplayCD():	
	unstuck_label.text = str(int(unstuck_cd))
func unstuckVisibility():
	if unstuck_cd == 0:
		unstuck_button.visible = true 
		unstuck_cd_progress_bar.visible = false
	else:
		unstuck_button.visible = false
		unstuck_cd_progress_bar.visible = true
		unstuck_cd_progress_bar.value = ((unstuck_cd/1000.0) * 100.0)
func _on_Unstcuk_pressed():
	if unstuck_cd == 0:
		unstuck_cd = 1000
		translation = Vector3(0, 10, 0)
func _on_OneSecondTimer_timeout():
	if unstuck_cd > 0:
		unstuck_cd -= 1
		if unstuck_cd < 0:
			unstuck_cd = 0
	updateFPS()
	debugText()
	roundPositionCoordinates()
	displayClock()

func _on_Area_body_entered(body):
	var aggro_power = -30
	var damage = rand_range(1, 90)
	if body.is_in_group("Enemy"):
		# Assuming that the player is the instigator, change the argument accordingly
		body.takedamage(damage,aggro_power, self)
func instanceui():
		var level_ui_scene = load("res://LevelUI.tscn")
		var level_ui_instance = level_ui_scene.instance()
		# Optionally, you can set the position or other properties of the instance here
		add_child(level_ui_instance)
#__________________________________________________________Weapon Management____________________________________________
#Main Weapon____________________________________________________________________________________________________________
onready var attachment_r = $Mesh/Armature020/Skeleton/HoldR
onready var detector = $Mesh/Detector
var sword0: PackedScene = preload("res://weapons/swords/sword0/sword0.tscn")
var sword1: PackedScene = preload("res://weapons/swords/sword1/sword1.tscn")
var sword2: PackedScene = preload("res://weapons/swords/sword3/sword3.tscn")
var currentInstance: Node = null  
var has_sword0 = false
var has_sword1 = false
var has_sword2 = false
var has_sword3 = false
var got_weapon = false


func fixInstance():
	attachment_r.add_child(currentInstance)
	currentInstance.get_node("CollisionShape").disabled = true
	currentInstance.scale = Vector3(100, 100, 100)
	got_weapon = true
func switch():
	if has_sword0:
		if currentInstance == null:
			currentInstance = sword0.instance()
			fixInstance()
	elif has_sword1:    
		if currentInstance == null:
			currentInstance = sword1.instance()
			fixInstance()
	elif has_sword2:    
		if currentInstance == null:
			currentInstance = sword2.instance()
			fixInstance()
func drop():
	if currentInstance != null and Input.is_action_just_pressed("drop") and got_weapon:
		attachment_r.remove_child(currentInstance)
		# Set the drop position
		var drop_position = global_transform.origin + direction.normalized() * 1.0
		currentInstance.global_transform.origin = Vector3(drop_position.x - rand_range(-0.3, 1), global_transform.origin.y + 0.2, drop_position.z + rand_range(-0.5, 0.88))
		# Set the scale of the dropped instance
		currentInstance.scale = Vector3(1, 1, 1)
		var collision_shape = currentInstance.get_node("CollisionShape")
		if collision_shape != null:
			collision_shape.disabled = false
		get_tree().root.add_child(currentInstance)
		# Reset variables
		has_sword0 = false
		has_sword1 = false
		has_sword2 = false
		got_weapon = false
		currentInstance = null
func pickItemsMainHand():
	var bodies = detector.get_overlapping_bodies()
	for body in bodies:
		if currentInstance == null:
			if Input.is_action_pressed("E"):
				if body.is_in_group("sword0") and not got_weapon:
					has_sword0 = true
					got_weapon = true  # Set the flag to prevent picking up multiple items simultaneously
					body.queue_free()  # Remove the picked-up item from the floor
				elif body.is_in_group("sword1") and not got_weapon:
					has_sword1 = true
					got_weapon = true  # Set the flag to prevent picking up multiple items simultaneously
					body.queue_free()  # Remove the picked-up item from the floor
				elif body.is_in_group("sword3") and not got_weapon:
					has_sword2 = true
					got_weapon = true  # Set the flag to prevent picking up multiple items simultaneously
					body.queue_free()  # Remove the picked-up item from the floor
		elif currentInstance != null and sec_currentInstance == null:
			if  Input.is_action_pressed("E"):
				if body.is_in_group("sword0") and not got_sec_weapon:
					has_sec_sword0 = true
					got_sec_weapon = true  # Set the flag to prevent picking up multiple items simultaneously
					body.queue_free()  # Remove the picked-up item from the floor
				elif body.is_in_group("sword1") and not got_sec_weapon:
					has_sec_sword1 = true
					got_sec_weapon = true  # Set the flag to prevent picking up multiple items simultaneously
					body.queue_free()  # Remove the picked-up item from the floor
				elif body.is_in_group("sword3") and not got_sec_weapon:
					has_sec_sword2 = true
					got_sec_weapon = true  # Set the flag to prevent picking up multiple items simultaneously
					body.queue_free()  # Remove the picked-up item from the floor
func MainWeapon():
	pickItemsMainHand()
	switch()
	if Input.is_action_just_pressed("drop"):
		drop()
		has_sword0 = false
		has_sword1 = false
		has_sword2 = false
#Secondary__________________________________________________________________________________________
onready var attachment_l = $Mesh/Armature020/Skeleton/HoldL
var sec_currentInstance: Node = null  
var has_sec_sword0 = false
var has_sec_sword1 = false
var has_sec_sword2 = false
var has_sec_sword3 = false
var got_sec_weapon = false


func fixSecInstance():
	attachment_l.add_child(sec_currentInstance)
	sec_currentInstance.get_node("CollisionShape").disabled = true
	sec_currentInstance.scale = Vector3(100, 100, 100)
	got_sec_weapon = true
func switchSec():
	if has_sec_sword0:
		if sec_currentInstance == null:
			sec_currentInstance = sword0.instance()
			fixSecInstance()
	elif has_sec_sword1:    
		if sec_currentInstance == null:
			sec_currentInstance = sword1.instance()
			fixSecInstance()
	elif has_sec_sword2:    
		if sec_currentInstance == null:
			sec_currentInstance = sword2.instance()
			fixSecInstance()
func dropSec():
	if sec_currentInstance != null and Input.is_action_just_pressed("drop") and got_sec_weapon:
		attachment_l.remove_child(sec_currentInstance)
		# Set the drop position
		var drop_position = global_transform.origin + direction.normalized() * 1.0
		sec_currentInstance.global_transform.origin = Vector3(drop_position.x - rand_range(-0.3, 1), global_transform.origin.y + 0.2, drop_position.z + rand_range(-0.5, 0.88))
		# Set the scale of the dropped instance
		sec_currentInstance.scale = Vector3(1, 1, 1)
		var collision_shape = sec_currentInstance.get_node("CollisionShape")
		if collision_shape != null:
			collision_shape.disabled = false
		get_tree().root.add_child(sec_currentInstance)
		# Reset variables
		has_sec_sword0 = false
		has_sec_sword1 = false
		has_sec_sword2 = false
		got_sec_weapon = false
		sec_currentInstance = null
func SecWeapon():
	switchSec()
	if Input.is_action_just_pressed("drop"):
		dropSec()
		has_sec_sword0 = false
		has_sec_sword1 = false
		has_sec_sword2 = false
